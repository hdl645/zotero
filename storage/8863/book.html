<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


<meta name="wpd_version" content="0.2">
<meta name="wpd_baseurl" content="http://www-cs-students.stanford.edu/~blynn/gitmagic/book.html">
<meta name="wpd_url" content="http://www-cs-students.stanford.edu/~blynn/gitmagic/book.html">
<meta name="wpd_date" content="2008-07-08T16:35Z">




  <meta name="generator" content="HTML Tidy for Linux/x86 (vers 6 November 2007), see www.w3.org">
  

  <title>Git Magic</title>
  <meta name="generator" content="DocBook XSL Stylesheets V1.73.2">
<script charset="utf-8" id="injection_graph_func" src="injection_graph_func.js"></script></head>
<body text="black" vlink="#840084" alink="#0000ff" bgcolor="white" link="#0000ff">
  <div class="book" lang="en">
    <div class="titlepage">
      <div>
        <div>
          <h1 class="title"><a name="id2427137" id="id2427137"></a>Git Magic</h1>
        </div>

        <div>
          <div class="author">
            <h3 class="author"><span class="firstname">Ben</span>
            <span class="surname">Lynn</span></h3>
          </div>
        </div>
      </div>
      <hr>
    </div>

    <div class="toc">
      <p><b>Table of Contents</b></p>

      <dl>
        <dt><span class="preface"><a href="#id2516934">Preface</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2476189">Thanks!</a></span></dt>

            <dt><span class="section"><a href="#id2476203">Links</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2476313">1.
        Introduction</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2476330">Work is
            Play</a></span></dt>

            <dt><span class="section"><a href="#id2476361">Version
            Control</a></span></dt>

            <dt><span class="section"><a href="#id2476411">Distributed Control</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href="#id2476519">A
                Silly Superstition</a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href="#id2476555">Merge
            Conflicts</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2476599">2. Basic
        Tricks</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2476611">Saving
            State</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href="#id2476667">Add,
                Delete, Rename</a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href="#id2476733">Advanced
            Undo/Redo</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href="#id2477250">Reverting</a></span></dt>
              </dl>
            </dd>

            <dt><span class="section"><a href="#id2477284">Downloading Files</a></span></dt>

            <dt><span class="section"><a href="#id2477327">The
            Bleeding Edge</a></span></dt>

            <dt><span class="section"><a href="#id2477353">Instant
            Publishing</a></span></dt>

            <dt><span class="section"><a href="#id2477450">What
            Have I Done?</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2526636">3. Cloning
        Around</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2526654">Sync
            Computers</a></span></dt>

            <dt><span class="section"><a href="#id2526707">Classic
            Source Control</a></span></dt>

            <dt><span class="section"><a href="#id2526806">Forking
            a Project</a></span></dt>

            <dt><span class="section"><a href="#id2526842">Ultimate
            Backups</a></span></dt>

            <dt><span class="section"><a href="#id2526871">Light-Speed Multitask</a></span></dt>

            <dt><span class="section"><a href="#id2526909">Guerilla
            Version Control</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2526992">4. Branch
        Wizardry</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2527056">The Boss
            Key</a></span></dt>

            <dt><span class="section"><a href="#id2527131">Dirty
            Work</a></span></dt>

            <dt><span class="section"><a href="#id2527317">Quick
            Fixes</a></span></dt>

            <dt><span class="section"><a href="#id2527355">Uninterrupted Workflow</a></span></dt>

            <dt><span class="section"><a href="#id2527464">Reorganizing a Medley</a></span></dt>

            <dt><span class="section"><a href="#id2527507">Managing
            Branches</a></span></dt>

            <dt><span class="section"><a href="#id2527540">Work How
            You Want</a></span></dt>

            <dd>
              <dl>
                <dt><span class="section"><a href="#id2527600">Personal Experience</a></span></dt>
              </dl>
            </dd>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2527654">5. Git
        Grandmastery</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2527664">Source
            Releases</a></span></dt>

            <dt><span class="section"><a href="#id2527684">Changelog Generation</a></span></dt>

            <dt><span class="section"><a href="#id2527710">Git Over
            SSH, HTTP</a></span></dt>

            <dt><span class="section"><a href="#id2527770">Commit
            What Changed</a></span></dt>

            <dt><span class="section"><a href="#id2527840">I Stand
            Corrected</a></span></dt>

            <dt><span class="section"><a href="#id2527870">&hellip; And
            Then Some</a></span></dt>

            <dt><span class="section"><a href="#id2527968">Local
            Changes Last</a></span></dt>

            <dt><span class="section"><a href="#id2528014">My
            Commit Is Too Big!</a></span></dt>

            <dt><span class="section"><a href="#id2528045">Don't
            Lose Your HEAD</a></span></dt>

            <dt><span class="section"><a href="#id2528101">HEAD-hunting</a></span></dt>

            <dt><span class="section"><a href="#id2528186">Making
            History</a></span></dt>

            <dt><span class="section"><a href="#id2528262">Building
            On Git</a></span></dt>

            <dt><span class="section"><a href="#id2528331">Daring
            Stunts</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2528433">6. Secrets
        Revealed</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2528450">Invisibility</a></span></dt>

            <dt><span class="section"><a href="#id2528502">Integrity</a></span></dt>

            <dt><span class="section"><a href="#id2528598">Intelligence</a></span></dt>

            <dt><span class="section"><a href="#id2528635">Indexing</a></span></dt>

            <dt><span class="section"><a href="#id2528661">Bare
            Repositories</a></span></dt>

            <dt><span class="section"><a href="#id2528710">Git's
            Origins</a></span></dt>
          </dl>
        </dd>

        <dt><span class="chapter"><a href="#id2528729">7. Git
        Shortcomings</a></span></dt>

        <dd>
          <dl>
            <dt><span class="section"><a href="#id2528753">Microsoft Windows</a></span></dt>

            <dt><span class="section"><a href="#id2528801">Unrelated Files</a></span></dt>

            <dt><span class="section"><a href="#id2528826">Who's
            Editing What?</a></span></dt>

            <dt><span class="section"><a href="#id2528871">File
            History</a></span></dt>

            <dt><span class="section"><a href="#id2528900">Initial
            Clone</a></span></dt>

            <dt><span class="section"><a href="#id2528925">Volatile
            Projects</a></span></dt>

            <dt><span class="section"><a href="#id2528985">Global
            Counter</a></span></dt>

            <dt><span class="section"><a href="#id2529011">Empty
            Subdirectories</a></span></dt>

            <dt><span class="section"><a href="#id2529028">Initial
            Commit</a></span></dt>
          </dl>
        </dd>
      </dl>
    </div>

    <div class="preface" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2516934" id="id2516934"></a>Preface</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2476189">Thanks!</a></span></dt>

          <dt><span class="section"><a href="#id2476203">Links</a></span></dt>
        </dl>
      </div>

      <p><a class="ulink" href="http://git.or.cz/" target="_top">Git</a> is a version control Swiss army knife. A
      reliable versatile multipurpose revision control tool whose
      extraordinary flexibility makes it tricky to learn, let alone
      master. I'm recording what I've figured out so far in these
      pages, because I initially had difficulty understanding
      <a class="ulink" href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html" target="_top">the Git user manual</a>.</p>

      <p>As Arthur C. Clarke observed, any sufficiently advanced
      technology is indistinguishable from magic. This is a great
      way to approach Git: newbies can ignore its inner workings
      and view Git as a gizmo that can amaze friends and infuriate
      enemies with its wondrous abilities.</p>

      <p>Rather than go into details, we provide rough instructions
      for particular effects. After repeated use, gradually you
      will understand how each trick works, and how to tailor the
      recipes for your needs.</p>

      <div class="itemizedlist">
        <p class="title"><b>Other Editions</b></p>

        <ul type="disc">
          <li><a class="ulink" href="http://www-cs-students.stanford.edu/%7Eblynn/gitmagic/book.html" target="_top">Single webpage</a>: barebones HTML, with no
          CSS.</li>

          <li><a class="ulink" href="http://www-cs-students.stanford.edu/%7Eblynn/gitmagic/book.pdf" target="_top">PDF
          file</a>: printer-friendly.</li>
        </ul>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476189" id="id2476189"></a>Thanks!</h2>
            </div>
          </div>
        </div>

        <p>Kudos to Dustin Sallings, Alberto Bertogli, James
        Cameron, Douglas Livingstone, Michael Budde, Richard
        Albury, Tarmigan and Derek Mahar for suggestions and
        improvements. [If I've left you out, please tell me because
        I often forget to update this section.]</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476203" id="id2476203"></a>Links</h2>
            </div>
          </div>
        </div>

        <p>I once listed some references, but it's too
        time-consuming to maintain. Besides, anyone can simply use
        <a class="ulink" href="http://www.google.com/" target="_top">a search engine</a> to find Git <a class="ulink" href="http://www.google.com/search?q=git+tutorial" target="_top">tutorials</a>, <a class="ulink" href="http://www.google.com/search?q=git+guide" target="_top">guides</a>, and <a class="ulink" href="http://www.google.com/search?q=git+comparison" target="_top">comparisons</a> with <a class="ulink" href="http://www.google.com/search?q=git+subversion" target="_top">Subversion</a>, <a class="ulink" href="http://www.google.com/search?q=git+mercurial" target="_top">Mercurial</a>, and other version control
        systems.</p>

        <div class="itemizedlist">
          <p class="title"><b>Free Git hosting</b></p>

          <ul type="disc">
            <li><a class="ulink" href="http://repo.or.cz/" target="_top">http://repo.or.cz/</a> hosts free projects,
            <a class="ulink" href="http://repo.or.cz/w/gitmagic.git" target="_top">including this guide</a>.</li>

            <li><a class="ulink" href="http://gitorious.org/" target="_top">http://gitorious.org/</a> is another Git
            hosting site aimed at open-source projects.</li>

            <li><a class="ulink" href="http://github.com/" target="_top">http://github.com/</a> hosts open-source
            projects for free, <a class="ulink" href="http://github.com/blynn/gitmagic/tree/master" target="_top">including this guide</a>, and private projects
            for a fee.</li>
          </ul>
        </div>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2476313" id="id2476313"></a>Chapter&nbsp;1.&nbsp;Introduction</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2476330">Work is
          Play</a></span></dt>

          <dt><span class="section"><a href="#id2476361">Version
          Control</a></span></dt>

          <dt><span class="section"><a href="#id2476411">Distributed Control</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href="#id2476519">A
              Silly Superstition</a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href="#id2476555">Merge
          Conflicts</a></span></dt>
        </dl>
      </div>

      <p>I'll use an analogy to introduce version control. See
      <a class="ulink" href="http://en.wikipedia.org/wiki/Revision_control" target="_top">the Wikipedia entry on revision control</a> for a
      saner explanation.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476330" id="id2476330"></a>Work is Play</h2>
            </div>
          </div>
        </div>

        <p>I've played computer games almost all my life. In
        contrast, I only started using version control systems as
        an adult. I suspect I'm not alone, and comparing the two
        may make these concepts easier to explain and
        understand.</p>

        <p>Think of editing your code or document, or whatever, as
        playing a game. Once you've made a lot of progress, you'd
        like to save. To do so, you click on the "Save" button in
        your trusty editor.</p>

        <p>But this will overwrite the old version. It's like those
        old school games which only had one save slot: sure you
        could save, but you could never go back to an older state.
        Which was a shame, because your previous save might have
        been right at a exceptionally fun part of the game that
        you'd like to revisit one day. Or worse still, your current
        save is in an unwinnable state, and you have to start
        again.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476361" id="id2476361"></a>Version Control</h2>
            </div>
          </div>
        </div>

        <p>When editing, you can "Save As&hellip;" a different file, or
        copy the file somewhere first before saving if you want to
        savour old versions. Maybe compress them too to save space.
        This is a primitive and labour-intensive form of version
        control. Computer games improved on this long ago, many of
        them providing multiple automatically timestamped save
        slots.</p>

        <p>Let's make the problem slightly tougher. Say you have a
        bunch of files that go together, such as source code for a
        project, or files for a website. Now if you want to keep an
        old version you have to archive a whole directory. Keeping
        many versions around by hand is inconvenient, and quickly
        becomes expensive.</p>

        <p>With some computer games, a saved game really does
        consist of a directory full of files. These games hide this
        detail from the player and present a convenient interface
        to manage different versions of this directory.</p>

        <p>Version control systems are no different. They all have
        nice interfaces to manage a directory of stuff. You can
        save the state of the directory every so often, and you can
        load any one of the saved states later on. Unlike most
        computer games, they're usually smart about conserving
        space. Typically, only a few files change between version
        to version, and not by much. Storing the differences
        instead of entire new copies saves room.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476411" id="id2476411"></a>Distributed
              Control</h2>
            </div>
          </div>
        </div>

        <p>Now imagine a very difficult computer game. So difficult
        to finish that many experienced gamers all over the world
        decide to team up and share their saved games to try to
        beat it. Speedruns are real-life examples: players
        specializing in different levels of the same game
        collaborate to produce amazing results.</p>

        <p>How would you set up a system so they can get at each
        other's saves easily? And upload new ones?</p>

        <p>In the old days, every project used centralized version
        control. A server somewhere held all the saved games.
        Nobody else did. Every player kept at most a few saved
        games on their machine. When a player wanted to make
        progress, they'd download the latest save from the main
        server, play a while, save and upload back to the server
        for everyone else to use.</p>

        <p>What if a player wanted to get an older saved game for
        some reason? Maybe the current saved game is in an
        unwinnable state because somebody forgot to pick up an
        object back in level three, and they want to find the
        latest saved game where the game can still be completed. Or
        maybe they want to compare two older saved games to see how
        much work a particular player did.</p>

        <p>There could be many reasons to want to see an older
        revision, but the outcome is the same. They have to ask the
        central server for that old saved game. The more saved
        games they want, the more they need to communicate.</p>

        <p>The new generation of version control systems, of which
        Git is a member, are known as distributed systems, and can
        be thought of as a generalization of centralized systems.
        When players download from the main server they get every
        saved game, not just the latest one. It's as if they're
        mirroring the central server.</p>

        <p>This initial cloning operation can be expensive,
        especially if there's a long history, but it pays off in
        the long run. One immediate benefit is that when an old
        save is desired for any reason, communication with the
        central server is unnecessary.</p>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name="id2476519" id="id2476519"></a>A Silly Superstition</h3>
              </div>
            </div>
          </div>

          <p>A popular misconception is that distributed systems
          are ill-suited for projects requiring an official central
          repository. Nothing could be further from the truth.
          Photographing someone does not cause their soul to be
          stolen. Similarly, cloning the master repository does not
          diminish its importance.</p>

          <p>A good first approximation is that anything a
          centralized version control system can do, a
          well-designed distributed system can do better. Network
          resources are simply costlier than local resources. While
          we shall later see there are drawbacks to a distributed
          approach, one is less likely to make erroneous
          comparisons with this rule of thumb.</p>

          <p>A small project may only need a fraction of the
          features offered by such a system. But would you use
          Roman numerals when calculating with small numbers?
          Moreover, your project may grow beyond your original
          expectations. Using Git from the outset is like carrying
          a Swiss army knife even though you mostly use it to open
          bottles. On the day you desperately need a screwdriver
          you'll be glad you have more than a plain
          bottle-opener.</p>
        </div>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476555" id="id2476555"></a>Merge Conflicts</h2>
            </div>
          </div>
        </div>

        <p>An interesting problem arises in any type of revision
        control system. Suppose Alice and Bob have both
        independently downloaded the latest saved game. They both
        play the game a bit more and save. What if they both want
        to submit their new saves? Let's say Alice uploads first.
        Then when Bob tries to upload his save, the system realizes
        that his state does not chronologically follow Alice's
        state.</p>

        <p>Let us revert to editing a text file. Our computer game
        analogy becomes too thinly stretched since most games never
        worry about this.</p>

        <p>So suppose Alice has inserted a line at the beginning of
        a file, and Bob appends one at the end. They both upload
        their changes. Most systems will automatically deduce a
        reasonable course of action: accept and merge their
        changes, so both Alice's and Bob's edits are applied.</p>

        <p>Now suppose both Alice and Bob have made distinct edits
        to the same line. Then it is impossible to resolve the
        conflict without human intervention. The second person to
        upload is informed of a merge conflict, and they must
        either choose one edit over another, or revise the line
        entirely.</p>

        <p>More complex situations can arise. Version control
        systems handle the simpler cases themselves, and leave the
        difficult cases for humans. Usually their behaviour is
        configurable.</p>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2476599" id="id2476599"></a>Chapter&nbsp;2.&nbsp;Basic Tricks</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2476611">Saving
          State</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href="#id2476667">Add,
              Delete, Rename</a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href="#id2476733">Advanced
          Undo/Redo</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href="#id2477250">Reverting</a></span></dt>
            </dl>
          </dd>

          <dt><span class="section"><a href="#id2477284">Downloading Files</a></span></dt>

          <dt><span class="section"><a href="#id2477327">The
          Bleeding Edge</a></span></dt>

          <dt><span class="section"><a href="#id2477353">Instant
          Publishing</a></span></dt>

          <dt><span class="section"><a href="#id2477450">What Have
          I Done?</a></span></dt>
        </dl>
      </div>

      <p>Rather than diving into a sea of Git commands, use these
      elementary examples to get your feet wet. Despite their
      simplicity, each of them are useful.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476611" id="id2476611"></a>Saving State</h2>
            </div>
          </div>
        </div>

        <p>When I'm about to attempt something drastic I like to
        save the current state, so I can go back and try again
        should things go awry.</p>

        <p>Take a snapshot of all files in the current directory
        with:</p>
        <pre class="literallayout">$ git init
$ git add .
$ git commit -m "My first backup"
</pre>

        <p>The above sequence of commands should be memorized, or
        placed in a script, as they will be reused frequently.</p>

        <p>Then if something goes wrong, run:</p>
        <pre class="literallayout">$ git reset --hard
</pre>

        <p>to go back to where you were. To save the state
        again:</p>
        <pre class="literallayout">$ git commit -a -m "Another backup"
</pre>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name="id2476667" id="id2476667"></a>Add, Delete, Rename</h3>
              </div>
            </div>
          </div>

          <p>The above will only keep track of the files that were
          present when you first ran <span class="strong"><strong>git add</strong></span>. If you add new
          files or subdirectories, you'll have to tell Git:</p>
          <pre class="literallayout">$ git add NEWFILES...
</pre>

          <p>Similarly, if you want Git to forget about certain
          files, maybe because you've deleted them</p>
          <pre class="literallayout">$ git rm OLDFILES...
</pre>

          <p>Renaming a file is the same as removing the old name
          and adding the new name. There's also the shortcut
          <span class="strong"><strong>git mv</strong></span> which
          has the same syntax as the <span class="strong"><strong>mv</strong></span> command. For
          example:</p>
          <pre class="literallayout">$ git mv OLDFILE NEWFILE
</pre>
        </div>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2476733" id="id2476733"></a>Advanced
              Undo/Redo</h2>
            </div>
          </div>
        </div>

        <p>Sometimes you just want to go back and forget about
        every change past a certain point because they're all
        wrong.</p>

        <p>Then</p>
        <pre class="literallayout">$ git log
</pre>

        <p>shows you a list of recent commits, and their SHA1
        hashes. Next, type</p>
        <pre class="literallayout">$ git reset --hard SHA1_HASH
</pre>

        <p>to restore the state to a given commit and erase all
        newer commits from the record permanently.</p>

        <p>Other times you want to hop to an old state briefly. In
        this case, type:</p>
        <pre class="literallayout">$ git checkout SHA1_HASH
</pre>

        <p>This takes you back in time, while preserving newer
        commits. However, like time travel in a science-fiction
        movie, if you now edit and commit, you will be in an
        alternate reality, because your actions are different to
        what they were the first time around.</p>

        <p>This alternate reality is called a <span class="emphasis"><em>'branch</em></span>', and <a class="link" href="#branch">we'll have more to say about this later</a>.
        For now, just remember that</p>
        <pre class="literallayout">$ git checkout master
</pre>

        <p>will take you back to the present.</p>

        <p>Uncommitted changes travel in time with you when you run
        checkout.</p>

        <p>To take the computer game analogy again:</p>

        <div class="itemizedlist">
          <ul type="disc">
            <li><span class="strong"><strong><code class="literal">git reset --hard</code></strong></span>: load
            an old save and delete all saved games newer than the
            one just loaded.</li>

            <li><span class="strong"><strong><code class="literal">git checkout</code></strong></span>: load an
            old game, but if you play on, the game state will
            deviate from the newer saves you made the first time
            around. Any saved games you make now will end up in a
            separate branch representing the alternate reality you
            have entered. <a class="link" href="#branch">We deal
            with this later</a>.</li>
          </ul>
        </div>

        <p>You can choose only to restore particular files and
        subdirectories by appending them after the command.</p>

        <p>Don't like cutting and pasting hashes? Then use:</p>
        <pre class="literallayout">$ git checkout "@{10 minutes ago}" .
</pre>

        <p>Other time specifications work too. For example, you can
        ask for the 5th-last saved state:</p>
        <pre class="literallayout">$ git checkout "@{5}" .
</pre>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name="id2477250" id="id2477250"></a>Reverting</h3>
              </div>
            </div>
          </div>

          <p>In a court of law, events can be stricken from the
          record. Likewise, you can pick specific commits to
          undo.</p>
          <pre class="literallayout">$ git commit -a
$ git revert SHA1_HASH
</pre>

          <p>will undo just the commit with the given hash. Running
          <span class="strong"><strong>git log</strong></span>
          reveals the revert is recorded as a new commit.</p>
        </div>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2477284" id="id2477284"></a>Downloading Files</h2>
            </div>
          </div>
        </div>

        <p>Get a copy of a project managed with Git by typing:</p>
        <pre class="literallayout">$ git clone git://server/path/to/files
</pre>

        <p>For example, to get all the files I used to create this
        site:</p>
        <pre class="literallayout">$ git clone git://git.or.cz/gitmagic.git
</pre>

        <p>We'll have much to say about the <span class="strong"><strong>clone</strong></span> command soon.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2477327" id="id2477327"></a>The Bleeding Edge</h2>
            </div>
          </div>
        </div>

        <p>If you've already downloaded a copy of a project using
        <span class="strong"><strong>git clone</strong></span>, you
        can upgrade to the latest version with:</p>
        <pre class="literallayout">$ git pull
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2477353" id="id2477353"></a>Instant
              Publishing</h2>
            </div>
          </div>
        </div>

        <p>Let's say you've written a script you'd like to share
        with others. You could just tell them to download from your
        computer, but if they do so while you're improving the
        script or making experimental changes, they could wind up
        in trouble. Of course, this is why release cycles exist.
        Developers work on code, and when they feel it's suitable
        for others, they release the code.</p>

        <p>To do this with Git, in the directory where your script
        resides:</p>
        <pre class="literallayout">$ git init
$ git add .
$ git commit -m "First release"
</pre>

        <p>Then tell your users to run:</p>
        <pre class="literallayout">$ git clone your.computer:/path/to/script
</pre>

        <p>to download your script. This assumes they have ssh
        access. If not, run <span class="strong"><strong>git
        daemon</strong></span> and tell your users to instead
        run:</p>
        <pre class="literallayout">$ git clone git://your.computer/path/to/script
</pre>

        <p>From now on, every time your script is ready for
        release, execute:</p>
        <pre class="literallayout">$ git commit -a -m "Next release"
</pre>

        <p>and your users can upgrade their version by changing to
        the directory containing your script and typing:</p>
        <pre class="literallayout">$ git pull
</pre>

        <p>Your users will never end up with a version of your
        script you don't want them to see. Obviously this trick
        works for anything, not just scripts.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2477450" id="id2477450"></a>What Have I Done?</h2>
            </div>
          </div>
        </div>

        <p>Find out what changes you've made since the last commit
        with:</p>
        <pre class="literallayout">$ git diff
</pre>

        <p>Or since yesterday:</p>
        <pre class="literallayout">$ git diff "@{yesterday}"
</pre>

        <p>Or between a particular version and 2 versions ago:</p>
        <pre class="literallayout">$ git diff SHA1_HASH "@{2}"
</pre>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2526636" id="id2526636"></a>Chapter&nbsp;3.&nbsp;Cloning
            Around</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2526654">Sync
          Computers</a></span></dt>

          <dt><span class="section"><a href="#id2526707">Classic
          Source Control</a></span></dt>

          <dt><span class="section"><a href="#id2526806">Forking a
          Project</a></span></dt>

          <dt><span class="section"><a href="#id2526842">Ultimate
          Backups</a></span></dt>

          <dt><span class="section"><a href="#id2526871">Light-Speed Multitask</a></span></dt>

          <dt><span class="section"><a href="#id2526909">Guerilla
          Version Control</a></span></dt>
        </dl>
      </div>

      <p>In older version control systems, checkout is the standard
      operation to get files. You checkout a bunch of files in the
      requested saved state.</p>

      <p>In Git and other distributed version control systems,
      cloning is the standard operation. To get files you create a
      clone of the entire repository. In other words, you
      practically create a mirror of the central server. Anything
      the main repository can do, you can do.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2526654" id="id2526654"></a>Sync Computers</h2>
            </div>
          </div>
        </div>

        <p>This is the reason I first used Git. I can tolerate
        making tarballs or using <span class="strong"><strong>rsync</strong></span> for backups and
        basic syncing. But sometimes I edit on my laptop, other
        times on my desktop, and the two may not have talked to
        each other in between.</p>

        <p>Initialize a Git repository and commit your files as
        above on one machine. Then on the other:</p>
        <pre class="literallayout">$ git clone other.computer:/path/to/files
</pre>

        <p>to create a second copy of the files and Git repository.
        From now on,</p>
        <pre class="literallayout">$ git commit -a
$ git pull other.computer:/path/to/files
</pre>

        <p>will pull in the state of the files on the other
        computer into the one you're working on. If you've recently
        made conflicting edits in the same file, Git will let you
        know and you should commit again after resolving them.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2526707" id="id2526707"></a>Classic Source
              Control</h2>
            </div>
          </div>
        </div>

        <p>Initialize a Git repository for your files:</p>
        <pre class="literallayout">$ git init
$ git add .
$ git commit -m "Initial commit"
</pre>

        <p>On the central server, initialize an empty Git
        repository with some name, and start the Git daemon if
        necessary:</p>
        <pre class="literallayout">$ GIT_DIR=proj.git git init
$ git daemon --detach  # it might already be running
</pre>

        <p>Some public hosts, such as <a class="ulink" href="http://repo.or.cz/" target="_top">repo.or.cz</a>, will have
        a different method for setting up the initially empty Git
        repository, such as filling in a form on a webpage.</p>

        <p>Push your project to the central server with:</p>
        <pre class="literallayout">$ git push git://central.server/path/to/proj.git HEAD
</pre>

        <p>We're ready. To check out source, a developer types</p>
        <pre class="literallayout">$ git clone git://central.server/path/to/proj.git
</pre>

        <p>After making changes, the code is checked in to the main
        server by:</p>
        <pre class="literallayout">$ git commit -a
$ git push
</pre>

        <p>If the main server has been updated, the latest version
        needs to be checked out before the push. To sync to the
        latest version:</p>
        <pre class="literallayout">$ git commit -a
$ git pull
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2526806" id="id2526806"></a>Forking a Project</h2>
            </div>
          </div>
        </div>

        <p>Sick of the way a project is being run? Think you could
        do a better job? Then on your server:</p>
        <pre class="literallayout">$ git clone git://main.server/path/to/files
</pre>

        <p>Next tell everyone about your fork of the project at
        your server.</p>

        <p>At any later time, you can merge in the changes from the
        original project with:</p>
        <pre class="literallayout">$ git pull
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2526842" id="id2526842"></a>Ultimate Backups</h2>
            </div>
          </div>
        </div>

        <p>Want numerous tamper-proof geographically diverse
        redundant archives? If your project has many developers,
        don't do anything! Every clone of your code is effectively
        a backup. Not just of the current state of the project, but
        of your project's entire history. Thanks to cryptographic
        hashing, if anyone's clone becomes corrupted, it will be
        spotted as soon as they try to communicate with others.</p>

        <p>If your project is not so popular, find as many servers
        as you can to host clones.</p>

        <p>The truly paranoid should always write down the latest
        20-byte SHA1 hash of the HEAD somewhere safe. It has to be
        safe, not private. For example, publishing it in a
        newspaper would work well, because it's hard for an
        attacker to alter every copy of a newspaper.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2526871" id="id2526871"></a>Light-Speed
              Multitask</h2>
            </div>
          </div>
        </div>

        <p>Say you want to work on several features in parallel.
        Then after committing your project:</p>
        <pre class="literallayout">$ git clone . /some/new/directory
</pre>

        <p>Git exploits hard links and file sharing as much as
        safely possible to create this clone, so it will be ready
        in a flash, and you can now work on two independent
        features simultaneously. For example, you can edit one
        clone while the other is compiling.</p>

        <p>At any time, you can commit and pull changes from the
        other clone.</p>
        <pre class="literallayout">$ git pull /the/other/clone
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2526909" id="id2526909"></a>Guerilla Version
              Control</h2>
            </div>
          </div>
        </div>

        <p>Are you working on a project that uses some other
        version control system, and you sorely miss Git? Then
        initialize a Git repository in your working directory:</p>
        <pre class="literallayout">$ git init
$ git add .
$ git commit -m "Initial commit"
</pre>

        <p>then clone it, at light speed:</p>
        <pre class="literallayout">$ git clone . /some/new/directory
</pre>

        <p>Now go to the new directory and work here instead, using
        Git to your heart's content. Once in a while, you'll want
        to sync with everyone else, in which case go to the
        original directory, sync using the other version control
        system, and type:</p>
        <pre class="literallayout">$ git add .
$ git commit -m "Sync with everyone else"
</pre>

        <p>Then go to the new directory and run:</p>
        <pre class="literallayout">$ git commit -a -m "Description of my changes"
$ git pull
</pre>

        <p>The procedure for giving your changes to everyone else
        depends on the other version control system. The new
        directory contains the files with your changes. Run
        whatever commands of the other version control system are
        needed to upload them to the central repository.</p>

        <p>Tip: If you want to interact with a Subversion
        repository, check out the <span class="strong"><strong>git
        svn</strong></span> command, which can automate all this
        (and more) for you.</p>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2526992" id="id2526992"></a>Chapter&nbsp;4.&nbsp;Branch
            Wizardry</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2527056">The Boss
          Key</a></span></dt>

          <dt><span class="section"><a href="#id2527131">Dirty
          Work</a></span></dt>

          <dt><span class="section"><a href="#id2527317">Quick
          Fixes</a></span></dt>

          <dt><span class="section"><a href="#id2527355">Uninterrupted Workflow</a></span></dt>

          <dt><span class="section"><a href="#id2527464">Reorganizing a Medley</a></span></dt>

          <dt><span class="section"><a href="#id2527507">Managing
          Branches</a></span></dt>

          <dt><span class="section"><a href="#id2527540">Work How
          You Want</a></span></dt>

          <dd>
            <dl>
              <dt><span class="section"><a href="#id2527600">Personal Experience</a></span></dt>
            </dl>
          </dd>
        </dl>
      </div>

      <p>Instant branching and merging are the most lethal of Git's
      killer features.</p>

      <p><span class="strong"><strong>Problem</strong></span>:
      External factors inevitably necessitate context switching. A
      severe bug manifests in the released version suddenly without
      warning, and must be fixed as soon as possible at all costs.
      The deadline for a certain feature is imminent. The guy who
      wrote a certain function is about to leave, so you should
      drop what you are doing and get him to help you understand
      it.</p>

      <p>Interrupting your train of thought can be detrimental to
      your productivity, and the slower and less convenient it is
      to switch contexts, the greater the loss. With centralized
      version control we must download a fresh working copy from
      the central server. Distributed systems fare better, as we
      can clone the desired version locally.</p>

      <p>But cloning still entails copying the whole working
      directory as well as the entire history up to the given
      point. Even though Git reduces the cost of this with file
      sharing and hard links, the project files themselves must be
      recreated in their entirety in the new working directory.</p>

      <p><span class="strong"><strong>Solution</strong></span>: Git
      has a better tool for these situations that is much faster
      and more space-efficient than cloning: <span class="strong"><strong>git branch</strong></span>.</p>

      <p>With this magic word, the files in your directory suddenly
      shapeshift from one version to another. This transformation
      can do more than merely go back or forward in history. Your
      files can morph from the last release to the experimental
      version to the current development version to your friend's
      version and so on.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527056" id="id2527056"></a>The Boss Key</h2>
            </div>
          </div>
        </div>

        <p>Ever play one of those games where at the push of a
        button ("the boss key"), the screen would instantly display
        a spreadsheet or something? So if the boss walked in the
        office while you were playing the game you could quickly
        hide this fact?</p>

        <p>In some directory:</p>
        <pre class="literallayout">$ echo "I'm smarter than my boss" &gt; myfile.txt
$ git init
$ git add .
$ git commit -m "Initial commit"
</pre>

        <p>We have created a Git repository that tracks one text
        file containing a certain message. Now type:</p>
        <pre class="literallayout">$ git checkout -b boss  # nothing seems to change after this
$ echo "My boss is smarter than me" &gt; myfile.txt
$ git commit -a -m "Another commit"
</pre>

        <p>It looks like we've just overwritten our file and
        committed it. But it's an illusion. Type:</p>
        <pre class="literallayout">$ git checkout master  # switch to original version of the file
</pre>

        <p>and hey presto! The text file is restored. And if the
        boss decides to snoop around this directory, type:</p>
        <pre class="literallayout">$ git checkout boss  # switch to version suitable for boss' eyes
</pre>

        <p>You can switch between the two versions of the file as
        much as you like, and commit to each independently.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527131" id="id2527131"></a>Dirty Work</h2>
            </div>
          </div>
        </div>

        <p><a name="branch" id="branch"></a>Say you're working on
        some feature, and for some reason, you need to go back to
        an old version and temporarily put in a few prints
        statements to see how something works. Then:</p>
        <pre class="literallayout">$ git commit -a
$ git checkout SHA1_HASH
</pre>

        <p>Now you can add ugly temporary code all over the place.
        You can even commit these changes. When you're done,</p>
        <pre class="literallayout">$ git checkout master
</pre>

        <p>to return to your original work. Observe that any
        uncommitted changes are carried over.</p>

        <p>What if you wanted to save the temporary changes after
        all? Easy:</p>
        <pre class="literallayout">$ git checkout -b dirty
</pre>

        <p>and commit before switching back to the master branch.
        Whenever you want to return to the dirty changes, simply
        type</p>
        <pre class="literallayout">$ git checkout dirty
</pre>

        <p>We touched upon this command in an earlier chapter, when
        discussing loading old states. At last we can tell the
        whole story: the files change to the requested state, but
        we must leave the master branch. Any commits made from now
        on take your files down a different road, which can be
        named later.</p>

        <p>In other words, after checking out an old state, Git
        automatically puts you in a new, unnamed branch, which can
        be named and saved with <span class="strong"><strong>git
        checkout -b</strong></span>.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527317" id="id2527317"></a>Quick Fixes</h2>
            </div>
          </div>
        </div>

        <p>You're in the middle of something when you are told to
        drop everything and fix a newly discovered bug:</p>
        <pre class="literallayout">$ git commit -a
$ git checkout -b fixes SHA1_HASH
</pre>

        <p>Then once you've fixed the bug:</p>
        <pre class="literallayout">$ git commit -a -m "Bug fixed"
$ git push  # to the central repository
$ git checkout master
</pre>

        <p>and resume work on your original task.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527355" id="id2527355"></a>Uninterrupted
              Workflow</h2>
            </div>
          </div>
        </div>

        <p>Some projects require your code to be reviewed before
        you may submit it. To make life easier for those reviewing
        your code, if you have a big change to make you might break
        it into two or more parts, and get each part separately
        reviewed.</p>

        <p>What if the second part cannot be written until the
        first part is approved and checked in? In many version
        control systems, you'd have to send the first part to the
        reviewers, and then wait until it has been approved before
        starting on the second part.</p>

        <p>Actually that's not quite true, but in these systems
        editing Part II before Part I has been submitted involves a
        lot of suffering and hardship. In Git, branching and
        merging are painless (a technical term for fast and local).
        So after you've committed the first part and sent it for
        review:</p>
        <pre class="literallayout">$ git checkout -b part2
</pre>

        <p>Next, code the second part of the big change without
        waiting for the first part to be accepted. When the first
        part is approved and submitted,</p>
        <pre class="literallayout">$ git checkout master
$ git merge part2
$ git branch -d part2  # don't need this branch anymore
</pre>

        <p>and the second part of the change is ready to
        review.</p>

        <p>But wait! What if it wasn't that simple? Say you made a
        mistake in the first part, which you have to correct before
        submitting. No problem! First, switch back to the master
        branch with</p>
        <pre class="literallayout">$ git checkout master
</pre>

        <p>Fix the issue with the first part of the change and hope
        it gets approved. If not we simply repeat this step. You'll
        probably want to merge the fixed version of Part I into
        Part II as well:</p>
        <pre class="literallayout">$ git checkout part2
$ git merge master
</pre>

        <p>Now it's the same as before. Once the first part has
        been approved and submitted:</p>
        <pre class="literallayout">$ git checkout master
$ git merge part2
$ git branch -d part2
</pre>

        <p>and again, the second part is ready to be reviewed.</p>

        <p>It's easy to extend this trick for any number of
        parts.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527464" id="id2527464"></a>Reorganizing a
              Medley</h2>
            </div>
          </div>
        </div>

        <p>Perhaps you like to work on all aspects of a project in
        the same branch. You want to keep works-in-progress to
        yourself and want others to see your commits only when they
        have been neatly organized. Start a couple of branches:</p>
        <pre class="literallayout">$ git checkout -b sanitized
$ git checkout -b medley
</pre>

        <p>Next, work on anything: fix bugs, add features, add
        temporary code, and so forth, committing often along the
        way. Then:</p>
        <pre class="literallayout">$ git checkout sanitized
$ git cherry-pick SHA1_HASH
</pre>

        <p>applies a given commit to the "sanitized" branch. With
        appropriate cherry-picks you can construct a branch that
        contains only permanent code, and has related commits
        grouped together.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527507" id="id2527507"></a>Managing Branches</h2>
            </div>
          </div>
        </div>

        <p>Type:</p>
        <pre class="literallayout">$ git branch
</pre>

        <p>to list all the branches. There is always a branch named
        "master", and you start here by default. Some advocate
        leaving the "master" branch untouched and creating new
        branches for your own edits.</p>

        <p>See <span class="strong"><strong>git help
        branch</strong></span> for other branch operations.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527540" id="id2527540"></a>Work How You Want</h2>
            </div>
          </div>
        </div>

        <p>Applications such as <a class="ulink" href="http://www.mozilla.com/" target="_top">Mozilla Firefox</a>
        allow you to open multiple tabs and multiple windows.
        Switching tabs gives you different content in the same
        window. Git branching is like tabs for your working
        directory. Continuing this analogy, Git cloning is like
        opening a new window. Being able to do both easily makes
        for a better user experience.</p>

        <p>On a higher level, several Linux window managers allow
        you to have multiple desktops, which means you can
        instantly view a different state of the desktop. This is
        similar to branching in Git, whereas Git cloning would be
        like attaching another monitor where you can open more
        windows.</p>

        <p>Yet another example is the <a class="ulink" href="http://www.gnu.org/software/screen/" target="_top"><span class="strong"><strong>screen</strong></span></a> utility. This
        gem allows you to create, destroy and switch between
        multiple terminal sessions in the same terminal. Instead of
        opening new terminals (clone), you can use the same one if
        you run <span class="strong"><strong>screen</strong></span>
        (branch). In fact, you can do a lot more with <span class="strong"><strong>screen</strong></span> but that's a topic
        for another text.</p>

        <p>Cloning, branching and merging are fast and local in
        Git, encouraging you to use the combination that best suits
        you. Git allows you to work exactly how you want.</p>

        <div class="section" lang="en">
          <div class="titlepage">
            <div>
              <div>
                <h3 class="title"><a name="id2527600" id="id2527600"></a>Personal Experience</h3>
              </div>
            </div>
          </div>

          <p>The equivalent of branching and cloning in centralized
          version control systems, when it exists, requires network
          communication. This precludes working offline, and means
          these systems need more expensive network infrastructure,
          especially as the number of users grows.</p>

          <p>Most importantly, these operations will be slower to
          some degree, usually to the point where users won't
          bother using them unless absolutely necessary. And when
          they absolutely have to run slow commands, productivity
          suffers because of an interrupted work flow.</p>

          <p>I experienced these phenomena first-hand. Git was the
          first version control system I used, and I grew
          accustomed to it, taking many features for granted. I did
          not know what centralized systems were like, and assumed
          they were similar. Later, I was forced to use one.</p>

          <p>Often I have a flaky internet connection. This matters
          little with Git, but makes development unbearable with a
          centralized system.</p>

          <p>Additionally, I found myself conditioned to avoid
          certain commands because of the latencies involved, which
          ultimately prevented me from following the work flow I
          wanted.</p>

          <p>When I had to run a slow command, the interruption to
          my train of thought dealt a disproportionate amount of
          damage. While waiting for server communcation to
          complete, I'd do something else to pass the time, such as
          check email or write documentation. By the time I
          returned to the original task, the command had already
          finished long ago. I would then spend a long time trying
          to remember what I was doing.</p>
        </div>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2527654" id="id2527654"></a>Chapter&nbsp;5.&nbsp;Git
            Grandmastery</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2527664">Source
          Releases</a></span></dt>

          <dt><span class="section"><a href="#id2527684">Changelog
          Generation</a></span></dt>

          <dt><span class="section"><a href="#id2527710">Git Over
          SSH, HTTP</a></span></dt>

          <dt><span class="section"><a href="#id2527770">Commit
          What Changed</a></span></dt>

          <dt><span class="section"><a href="#id2527840">I Stand
          Corrected</a></span></dt>

          <dt><span class="section"><a href="#id2527870">&hellip; And Then
          Some</a></span></dt>

          <dt><span class="section"><a href="#id2527968">Local
          Changes Last</a></span></dt>

          <dt><span class="section"><a href="#id2528014">My Commit
          Is Too Big!</a></span></dt>

          <dt><span class="section"><a href="#id2528045">Don't Lose
          Your HEAD</a></span></dt>

          <dt><span class="section"><a href="#id2528101">HEAD-hunting</a></span></dt>

          <dt><span class="section"><a href="#id2528186">Making
          History</a></span></dt>

          <dt><span class="section"><a href="#id2528262">Building
          On Git</a></span></dt>

          <dt><span class="section"><a href="#id2528331">Daring
          Stunts</a></span></dt>
        </dl>
      </div>

      <p>This pretentiously named page is my dumping ground for
      uncategorized Git tricks.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527664" id="id2527664"></a>Source Releases</h2>
            </div>
          </div>
        </div>

        <p>For my projects, Git tracks exactly the files I'd like
        to archive and release to users. To create a tarball of the
        source code, I run:</p>
        <pre class="literallayout">$ git archive --format=tar --prefix=proj-1.2.3/ HEAD
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527684" id="id2527684"></a>Changelog
              Generation</h2>
            </div>
          </div>
        </div>

        <p>It's good practice to keep a <a class="ulink" href="http://en.wikipedia.org/wiki/Changelog" target="_top">changelog</a>, and some projects even require it. If
        you've been committing frequently, which you should,
        generate a Changelog by typing:</p>
        <pre class="literallayout">$ git log &gt; ChangeLog
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527710" id="id2527710"></a>Git Over SSH,
              HTTP</h2>
            </div>
          </div>
        </div>

        <p>Suppose you have ssh access to your web server, but it
        does not have Git installed. Then download, compile and
        install Git in your account.</p>

        <p>Create a repository in your web directory:</p>
        <pre class="literallayout">$ GIT_DIR=proj.git git init
</pre>

        <p>and in the "proj.git" directory, run</p>
        <pre class="literallayout">$ git --bare update-server-info
$ chmod a+x hooks/post-update
</pre>

        <p>From your computer, push via ssh:</p>
        <pre class="literallayout">$ git push web.server:/path/to/proj.git master
</pre>

        <p>and others get your project via:</p>
        <pre class="literallayout">$ git clone http://web.server/proj.git
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527770" id="id2527770"></a>Commit What
              Changed</h2>
            </div>
          </div>
        </div>

        <p>Telling Git when you've added, deleted and renamed files
        gets tedious. Instead, you can type:</p>
        <pre class="literallayout">$ git add .
$ git add -u
</pre>

        <p>Git will look at the files in the current directory and
        work out the details by itself. Instead of the second add
        command, run <code class="literal">git commit -a</code> if
        you also intend to commit at this time.</p>

        <p>You can perform the above in a single pass with:</p>
        <pre class="literallayout">$ git ls-files -d -m -o -z | xargs -0 git update-index --add --remove
</pre>

        <p>The <span class="strong"><strong>-z</strong></span> and
        <span class="strong"><strong>-0</strong></span> options
        prevent ill side-effects from filenames containing strange
        characters. Note this command adds ignored files. You may
        want to use the <code class="literal">-x</code> or
        <code class="literal">-X</code> option.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527840" id="id2527840"></a>I Stand Corrected</h2>
            </div>
          </div>
        </div>

        <p>Did you just commit, but wish you had typed a different
        message? Realized you forgot to add a file? Then:</p>
        <pre class="literallayout">$ git commit --amend
</pre>

        <p>can help you out.</p>

        <p>Since this changes the history, only do this if you have
        yet to push your changes, otherwise your tree will diverge
        from other trees. Of course, if you control all the other
        trees too, then there is no problem since you can overwrite
        them.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527870" id="id2527870"></a>&hellip; And Then Some</h2>
            </div>
          </div>
        </div>

        <p>Let's suppose the previous problem is ten times worse.
        After a lengthy session you've made a bunch of commits. But
        you're not quite happy with the way they're organized, and
        some of those commit messages could use rewording. This is
        quite likely if you've been saving early and saving often.
        Then type</p>
        <pre class="literallayout">$ git rebase -i HEAD~10
</pre>

        <p>and the last 10 commits will appear in your favourite
        $EDITOR. A sample excerpt:</p>
        <pre class="literallayout">pick 5c6eb73 Added repo.or.cz link
pick a311a64 Reordered analogies in "Work How You Want"
pick 100834f Added push target to Makefile
</pre>

        <p>Then:</p>

        <div class="itemizedlist">
          <ul type="disc">
            <li>Remove commits by deleting lines.</li>

            <li>Reorder commits by reordering lines.</li>

            <li>Replace "pick" with "edit" to mark a commit for
            amending.</li>

            <li>Replace "pick" with "squash" to merge a commit with
            the previous one.</li>
          </ul>
        </div>

        <p>Next run <span class="strong"><strong>git commit
        --amend</strong></span> if you marked a commit for editing.
        Otherwise, run:</p>
        <pre class="literallayout">$ git rebase --continue
</pre>

        <p>Again, only do this if no one else has a clone of your
        tree.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2527968" id="id2527968"></a>Local Changes
              Last</h2>
            </div>
          </div>
        </div>

        <p>You're working on an active project. You make some local
        commits over time, and then you sync with the official tree
        with a merge. This cycle repeats itself a few times before
        you're ready to push to the central tree.</p>

        <p>But now the history in your local Git clone is a messy
        jumble of your changes and the official changes. You'd
        prefer to see all your changes in one contiguous section,
        and after all the official changes.</p>

        <p>This is a job for <span class="strong"><strong>git
        rebase</strong></span> as described above. In many cases
        you can use the <span class="strong"><strong>--onto</strong></span> flag and avoid
        interaction.</p>

        <p>Also see the manpage for other amazing uses of this
        command, which really deserves a chapter of its own. You
        can split commits. You can even rearrange branches of a
        tree!</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528014" id="id2528014"></a>My Commit Is Too
              Big!</h2>
            </div>
          </div>
        </div>

        <p>Have you neglected to commit for too long? Been coding
        furiously and forgotten about source control until now?
        Made a series of unrelated changes, because that's your
        style?</p>

        <p>No worries, use <span class="strong"><strong>git add
        -i</strong></span> or <span class="strong"><strong>git
        commit -i</strong></span> to interactively choose which
        edits should belong to the next commit.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528045" id="id2528045"></a>Don't Lose Your
              HEAD</h2>
            </div>
          </div>
        </div>

        <p>The HEAD tag is like a cursor that normally points at
        the latest commit, advancing with each new commit. Some Git
        commands let you move it. For example:</p>
        <pre class="literallayout">$ git reset HEAD~3
</pre>

        <p>will move the HEAD three commits backwards in time. Thus
        all Git commands now act as if you hadn't made those last
        three commits, while your files remain in the present. See
        the git reset man page for some applications.</p>

        <p>But how can you go back to the future? The past commits
        do not know anything of the future.</p>

        <p>If you have the SHA1 of the original HEAD then:</p>
        <pre class="literallayout">$ git reset SHA1
</pre>

        <p>But suppose you never took it down? Don't worry, for
        commands like these, Git saves the original HEAD as a tag
        called ORIG_HEAD, and you can return safe and sound
        with:</p>
        <pre class="literallayout">$ git reset ORIG_HEAD
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528101" id="id2528101"></a>HEAD-hunting</h2>
            </div>
          </div>
        </div>

        <p>Perhaps ORIG_HEAD isn't enough. Perhaps you've just
        realized you made a monumental mistake last month and you
        need to go back to an ancient commit in a long-forgotten
        branch.</p>

        <p>It's hard to lose Git commits permanently, even after
        deleting branches. As long as you never run <span class="strong"><strong>git gc --prune</strong></span>, your
        commits are preserved forever and can be restored at any
        time.</p>

        <p>The trouble is finding the appropriate hash. You could
        look at all the hash values in <code class="literal">.git/objects</code> and use trial and error to
        find the one you want. But there's a much easier way.</p>

        <p>Git records every hash of a commit it computes in
        <code class="literal">.git/logs</code>. The subdirectory
        <code class="literal">refs</code> contains the history of
        all activity on all branches, while the file <code class="literal">HEAD</code> shows every hash value it has ever
        taken. The latter can be used to find hashes of commits on
        branches that have been accidentally lopped off.</p>

        <p>The reflog command provides a friendly interface to
        these log files. Try</p>
        <pre class="literallayout">$ git reflog
</pre>

        <p>and see its manpage for more information.</p>

        <p>Eventually, you may want to run <span class="strong"><strong>git gc --prune</strong></span> to recover
        space. Be aware that doing so prevents you from recovering
        lost HEADs.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528186" id="id2528186"></a>Making History</h2>
            </div>
          </div>
        </div>

        <p>Want to migrate a project to Git? If it's managed with
        one of the more well-known systems, then chances are
        someone has already written a script to export the whole
        history to Git.</p>

        <p>Otherwise, take a look at <span class="strong"><strong>git fast-import</strong></span>. This
        command takes text input in a specific format and creates
        Git history from scratch. Typically a script is cobbled
        together and run once to feed this command, migrating the
        project in a single shot.</p>

        <p>As an example, paste the following listing into
        temporary file, such as <code class="literal">/tmp/history</code>:</p>
        <pre class="screen">commit refs/heads/master
committer Alice &lt;alice@example.com&gt; Thu, 01 Jan 1970 00:00:00 +0000
data &lt;&lt;EOT
Initial commit.
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;stdio.h&gt;

int main() {
  printf("Hello, world!\n");
  return 0;
}
EOT


commit refs/heads/master
committer Bob &lt;bob@example.com&gt; Tue, 14 Mar 2000 01:59:26 -0800
data &lt;&lt;EOT
Replace printf() with write().
EOT

M 100644 inline hello.c
data &lt;&lt;EOT
#include &lt;unistd.h&gt;

int main() {
  write(1, "Hello, world!\n", 14);
  return 0;
}
EOT
</pre>

        <p>Then create a Git repository from this temporary file by
        typing:</p>
        <pre class="literallayout">$ mkdir project; cd project; git init
$ git fast-import &lt; /tmp/history
</pre>

        <p>You can checkout the latest version of the project
        with:</p>
        <pre class="literallayout">$ git checkout master .
</pre>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528262" id="id2528262"></a>Building On Git</h2>
            </div>
          </div>
        </div>

        <p>In true UNIX fashion, Git's design allows it to be
        easily used as a low-level component of other programs.
        There are GUI interfaces, web interfaces, alternative
        command-line interfaces, and perhaps soon you will have a
        script or two of your own that calls Git.</p>

        <p>One easy trick is to use built-in git aliases shorten
        your most frequently used commands:</p>
        <pre class="literallayout">$ git config --global alias.co checkout
$ git config --global --get-regexp alias  # display current aliases
alias.co checkout
$ git co foo                              # same as 'git checkout foo'
</pre>

        <p>Another is to print the current branch in the prompt, or
        window title. Invoking</p>
        <pre class="literallayout">$ git symbolic-ref HEAD
</pre>

        <p>shows the current branch name. In practice, you most
        likely want to remove the "refs/heads/" and ignore
        errors:</p>
        <pre class="literallayout">$ git symbolic-ref HEAD 2&gt; /dev/null | cut -b 12-
</pre>

        <p>See <a class="ulink" href="http://git.or.cz/" target="_top">the Git homepage</a> for more examples.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528331" id="id2528331"></a>Daring Stunts</h2>
            </div>
          </div>
        </div>

        <p>Recent versions of Git make it difficult for the user to
        accidentally destroy data. This is perhaps the most
        compelling reason to upgrade.</p>

        <p>Nonetheless, there are times you truly want to destroy
        data. We show how to override the safeguards for common
        commands. Only use them if you know what you are doing.</p>

        <p><span class="strong"><strong>Checkout</strong></span>:
        If you have uncommitted changes, a plain checkout fails. To
        destroy your changes, and checkout a given commit anyway,
        use the force flag:</p>
        <pre class="literallayout">$ git checkout -f COMMIT
</pre>

        <p>On the other hand, if you specify particular paths for
        checkout, then there are no safety checks. The supplied
        paths are quietly overwritten. Take care if you use
        checkout in this manner.</p>

        <p><span class="strong"><strong>Reset</strong></span>:
        Reset also fails in the presence of uncommitted changes. To
        force it through, run:</p>
        <pre class="literallayout">$ git reset --hard [COMMIT]
</pre>

        <p><span class="strong"><strong>Branch</strong></span>:
        Deleting branches fails if this causes changes to be lost.
        To force a deletion, type:</p>
        <pre class="literallayout">$ git branch -D BRANCH  # instead of -d
</pre>

        <p>Similarly, attempting to overwrite a branch via a move
        fails if data loss would ensue. To force a branch move,
        type:</p>
        <pre class="literallayout">$ git branch -M [SOURCE] TARGET  # instead of -m
</pre>

        <p>Unlike checkout and reset, the destruction is deferred.
        The changes are still stored in the .git subdirectory, and
        can be retrieved by recovering the appropriate hash from
        <code class="literal">.git/logs</code> (see "HEAD-hunting"
        above). The data is only deleted the next time garbage is
        collected.</p>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2528433" id="id2528433"></a>Chapter&nbsp;6.&nbsp;Secrets
            Revealed</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2528450">Invisibility</a></span></dt>

          <dt><span class="section"><a href="#id2528502">Integrity</a></span></dt>

          <dt><span class="section"><a href="#id2528598">Intelligence</a></span></dt>

          <dt><span class="section"><a href="#id2528635">Indexing</a></span></dt>

          <dt><span class="section"><a href="#id2528661">Bare
          Repositories</a></span></dt>

          <dt><span class="section"><a href="#id2528710">Git's
          Origins</a></span></dt>
        </dl>
      </div>

      <p>We take a peek under the hood and explain how Git performs
      its miracles. I will skimp over details. For in-depth
      descriptions refer to <a class="ulink" href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html" target="_top">the user manual</a>.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528450" id="id2528450"></a>Invisibility</h2>
            </div>
          </div>
        </div>

        <p>How can Git be so unobtrusive? Aside from occasional
        commits and merges, you can work as if you were unaware
        that version control exists. That is, until you need it,
        and that's when you're glad Git was watching over you the
        whole time.</p>

        <p>Other version control systems don't let you forget about
        them. Permissions of files may be read-only unless you
        explicitly tell the server which files you intend to edit.
        The central server might be keeping track of who's checked
        out which code, and when. When the network goes down,
        you'll soon suffer. Developers constantly struggle with
        virtual red tape and bureaucracy.</p>

        <p>The secret is the <code class="literal">.git</code>
        directory in your working directory. Git keeps the history
        of your project here. The initial "." stops it showing up
        in <code class="literal">ls</code> listings. Except when
        you're pushing and pulling changes, all version control
        operations operate within this directory.</p>

        <p>You have total control over the fate of your files
        because Git doesn't care what you do to them. Git can
        easily recreate a saved state from <code class="literal">.git</code> at any time.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528502" id="id2528502"></a>Integrity</h2>
            </div>
          </div>
        </div>

        <p>Most people associate cryptography with keeping
        information secret, but another equally important goal is
        keeping information safe. Proper use of cryptographic hash
        functions can prevent accidental or malicious data
        corruption.</p>

        <p>A SHA1 hash can be thought of as a unique 160-bit ID
        number for every string of bytes you'll encounter in your
        life. Actually more than that: every string of bytes that
        any human will ever use over many lifetimes. The hash of
        the whole contents of a file can be viewed as a unique ID
        number for that file.</p>

        <p>An important observation is that a SHA1 hash is itself a
        string of bytes, so we can hash strings of bytes containing
        other hashes.</p>

        <p>Roughly speaking, all files handled by Git are referred
        to by their unique ID, not by their filename. All data
        resides in files in the ".git/objects" subdirectory, where
        you won't find any normal filenames. The contents of files
        are strings of bytes we call <span class="emphasis"><em>'blobs</em></span>' and they are divorced
        from their filenames.</p>

        <p>The filenames are recorded somewhere though. They live
        in <span class="emphasis"><em>'tree</em></span>' objects,
        which are lists of filenames along with the IDs of their
        contents. Since the tree itself is a string of bytes, it
        too has a unique ID, which is how it is stored in the
        ".git/objects" subdirectory. Trees can appear on the lists
        of other trees, hence a directory tree and all the files
        within may be represented by trees and blobs.</p>

        <p>Lastly, a <span class="emphasis"><em>'commit</em></span>' contains a message, a
        few tree IDs and information on how they are related to
        each other. A commit is also a string of bytes, hence it
        too has a unique ID.</p>

        <p>You can see for yourself: take any hash you see in the
        <code class="literal">.git/objects</code> directory, and
        type</p>
        <pre class="literallayout">$ git cat-file -p SHA1_HASH
</pre>

        <p>Now suppose somebody tries to rewrite history and
        attempts to change the contents of a file in an ancient
        version. Then the ID of the file will change since it's now
        a different string of bytes. This changes the ID of any
        tree object referencing this file, which in turn changes
        the ID of all commit objects involving this tree. The
        corruption in the bad repository is exposed when everyone
        realizes all the commits since the mutilated file have the
        wrong IDs.</p>

        <p>I've ignored details such as file permissions and
        signatures. But in short, so long as the 20 bytes
        representing the last commit are safe, it's impossible to
        tamper with a Git repository.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528598" id="id2528598"></a>Intelligence</h2>
            </div>
          </div>
        </div>

        <p>How does Git know you renamed a file, even though you
        never mentioned the fact explicitly? Sure, you may have run
        <span class="strong"><strong>git mv</strong></span>, but
        that is exactly the same as a <span class="strong"><strong>git rm</strong></span> followed by a
        <span class="strong"><strong>git add</strong></span>.</p>

        <p>Git heuristically ferrets out renames and copies between
        successive versions. In fact, it can detect chunks of code
        being moved or copied around between files! Though it
        cannot cover all cases, it does a decent job, and this
        feature is always improving. If it fails to work for you,
        try options enabling more expensive copy detection, and
        consider upgrading.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528635" id="id2528635"></a>Indexing</h2>
            </div>
          </div>
        </div>

        <p>For every tracked file, Git records information such as
        its size, creation time and last modification time in a
        file known as the <span class="strong"><strong>index</strong></span>. To determine
        whether a file has changed, Git compares its current stats
        with that held the index. If they match, then Git can skip
        reading the file again.</p>

        <p>Since stat calls are vastly cheaper than reading file
        contents, if you only edit a few files, Git can update its
        state in almost no time.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528661" id="id2528661"></a>Bare Repositories</h2>
            </div>
          </div>
        </div>

        <p>You may have been wondering what format those online Git
        repositories use. They're plain Git repositories, just like
        your <code class="literal">.git</code> directory, except
        they've got names like <code class="literal">proj.git</code>, and they have no working
        directory associated with them.</p>

        <p>Most Git commands expect the Git index to live in
        <code class="literal">.git</code>, and will fail on these
        bare repositories. Fix this by setting the <code class="literal">GIT_DIR</code> environment variable to the path
        of the bare repository, or running Git within the directory
        itself with the <code class="literal">--bare</code>
        option.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528710" id="id2528710"></a>Git's Origins</h2>
            </div>
          </div>
        </div>

        <p>This <a class="ulink" href="http://lkml.org/lkml/2005/4/6/121" target="_top">Linux
        Kernel Mailing List post</a> describes the chain of events
        that led to Git. The entire thread is a fascinating
        archaeological site for Git historians.</p>
      </div>
    </div>

    <div class="chapter" lang="en">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title"><a name="id2528729" id="id2528729"></a>Chapter&nbsp;7.&nbsp;Git
            Shortcomings</h2>
          </div>
        </div>
      </div>

      <div class="toc">
        <p><b>Table of Contents</b></p>

        <dl>
          <dt><span class="section"><a href="#id2528753">Microsoft
          Windows</a></span></dt>

          <dt><span class="section"><a href="#id2528801">Unrelated
          Files</a></span></dt>

          <dt><span class="section"><a href="#id2528826">Who's
          Editing What?</a></span></dt>

          <dt><span class="section"><a href="#id2528871">File
          History</a></span></dt>

          <dt><span class="section"><a href="#id2528900">Initial
          Clone</a></span></dt>

          <dt><span class="section"><a href="#id2528925">Volatile
          Projects</a></span></dt>

          <dt><span class="section"><a href="#id2528985">Global
          Counter</a></span></dt>

          <dt><span class="section"><a href="#id2529011">Empty
          Subdirectories</a></span></dt>

          <dt><span class="section"><a href="#id2529028">Initial
          Commit</a></span></dt>
        </dl>
      </div>

      <p>There are some Git issues I've swept under the carpet.
      Some can be handled easily with scripts and hooks, some
      require reorganizing or redefining the project, and for the
      few remaining annoyances, one will just have to wait. Or
      better yet, pitch in and help!</p>

      <p>I've been playing around with some version control system
      ideas, and wrote <a class="ulink" href="http://www-cs-students.stanford.edu/%7Eblynn/gg/" target="_top">an experimental system based on Git</a>, which
      addresses some of these problems.</p>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528753" id="id2528753"></a>Microsoft Windows</h2>
            </div>
          </div>
        </div>

        <p>Git on Microsoft Windows can be cumbersome:</p>

        <div class="itemizedlist">
          <ul type="disc">
            <li><a class="ulink" href="http://cygwin.com/" target="_top">Cygwin</a>, a Linux-like environment for
            Windows, contains <a class="ulink" href="http://cygwin.com/packages/git/" target="_top">a
            Windows port of Git</a>.</li>

            <li><a class="ulink" href="http://code.google.com/p/msysgit/" target="_top">Git
            on MSys</a> is an alternative requiring minimal runtime
            support, though a few of the commands need some
            work.</li>
          </ul>
        </div>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528801" id="id2528801"></a>Unrelated Files</h2>
            </div>
          </div>
        </div>

        <p>If your project is very large and contains many
        unrelated files that are constantly being changed, Git may
        be disadvantaged more than other systems because single
        files are not tracked. Git tracks changes to the whole
        project, which is usually beneficial.</p>

        <p>A solution is to break up your project into pieces, each
        consisting of related files. Use <span class="strong"><strong>git submodule</strong></span> if you still
        want to keep everything in a single repository.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528826" id="id2528826"></a>Who's Editing
              What?</h2>
            </div>
          </div>
        </div>

        <p>Some version control systems force you to explicitly tag
        a file before editing. While this is especially annoying
        when this involves talking to a central server, it does
        have two benefits:</p>

        <div class="orderedlist">
          <ol type="1">
            <li>Diffs are quick because only the tagged files need
            be examined.</li>

            <li>When a central server stores the tags, one can
            discover who else is working on the file.</li>
          </ol>
        </div>

        <p>With appropriate scripting, you can achieve the same
        with Git. This requires cooperation from the programmer,
        who should execute particular scripts when editing a
        file.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528871" id="id2528871"></a>File History</h2>
            </div>
          </div>
        </div>

        <p>Since Git records project-wide changes, reconstructing
        the history of a single file requires more work than in
        version control systems that track individual files.</p>

        <p>The penalty is typically slight, and well worth having
        as other operations are incredibly efficient. For example,
        <code class="literal">git checkout</code> is faster than
        <code class="literal">cp -a</code>, and project-wide deltas
        compress better than collections of file-based deltas.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528900" id="id2528900"></a>Initial Clone</h2>
            </div>
          </div>
        </div>

        <p>Creating a clone is more expensive than checking out
        code in other version control systems when there is a
        lengthy history.</p>

        <p>The initial cost is worth paying in the long run, as
        most future operations will then be fast and offline.
        However, in some situations, it may be preferable to create
        a shallow clone with the <code class="literal">--depth</code> option. This is much faster, but
        the resulting clone has reduced functionality.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528925" id="id2528925"></a>Volatile Projects</h2>
            </div>
          </div>
        </div>

        <p>Git was written to be fast with respect to the size of
        the changes. Humans make small edits from version to
        version. A one-liner bugfix here, a new feature there,
        emended comments, and so forth. But if your files are
        radically different in successive revisions, then on each
        commit, your history necessarily grows by the size of your
        whole project.</p>

        <p>There is nothing any version control system can do about
        this, but standard Git users will suffer more since
        normally histories are cloned.</p>

        <p>The reasons why the changes are so great should be
        examined. Perhaps file formats should be changed. Minor
        edits should only cause minor changes to at most a few
        files.</p>

        <p>Or perhaps a database or backup/archival solution is
        what is actually being sought, not a version control
        system. For example, version control may be ill-suited for
        managing photos periodically taken from a webcam.</p>

        <p>If the files really must be constantly morphing and they
        really must be versioned, a possibility is to use Git in a
        centralized fashion. One can create shallow clones, which
        checks out little or no history of the project. Of course,
        many Git tools will be unavailable, and fixes must be
        submitted as patches. This is probably fine as it's unclear
        why anyone would want the history of wildly unstable
        files.</p>

        <p>Another example is a project depending on firmware,
        which takes the form of a huge binary file. The history of
        the firmware is uninteresting to users, and updates
        compress poorly, so firmware revisions would unnecessarily
        blow up the size of the repository.</p>

        <p>In this case, the source code should be stored in a Git
        repository, and the binary file should be kept separately.
        To make life easier, one could distribute a script that
        uses Git to clone the code, and rsync or a Git shallow
        clone for the firmware.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2528985" id="id2528985"></a>Global Counter</h2>
            </div>
          </div>
        </div>

        <p>Some centralized version control systems maintain a
        positive integer that increases when a new commit is
        accepted. Git refers to changes by their hash, which is
        better in many circumstances.</p>

        <p>But some people like having this integer around.
        Luckily, it's easy to write scripts so that with every
        update, the central Git repository increments an integer,
        perhaps in a tag, and associates it with the hash of the
        latest commit.</p>

        <p>Every clone could maintain such a counter, but this
        would probably be useless, since only the central
        repository and its counter matters to everyone.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2529011" id="id2529011"></a>Empty
              Subdirectories</h2>
            </div>
          </div>
        </div>

        <p>Empty subdirectories cannot be tracked. Create dummy
        files to work around this problem.</p>

        <p>The current implementation of Git, rather than its
        design, is to blame for this drawback. With luck, once Git
        gains more traction, more users will clamour for this
        feature and it will be implemented.</p>
      </div>

      <div class="section" lang="en">
        <div class="titlepage">
          <div>
            <div>
              <h2 class="title" style="clear: both;"><a name="id2529028" id="id2529028"></a>Initial Commit</h2>
            </div>
          </div>
        </div>

        <p>A stereotypical computer scientist counts from 0, rather
        than 1. Unfortunately, with respect to commits, git does
        not adhere to this convention. Many commands are unfriendly
        before the initial commit. Additionally, some corner cases
        must be handled specially, such as rebasing a branch with a
        different initial commit.</p>

        <p>Git would benefit from defining the zero commit: as soon
        as a repository is constructed, HEAD would be set to the
        string consisting of 20 zero bytes. This special commit
        represents an empty tree, with no parent, at some time
        predating all Git repositories.</p>

        <p>Then running git log, for example, would inform the user
        that no commits have been made yet, instead of exiting with
        a fatal error. Similarly for other tools.</p>

        <p>Every initial commit is implicitly a descendant of this
        zero commit. For example, rebasing an unrelated branch
        would cause the whole branch to be grafted on to the
        target. Currently, all but the initial commit is applied,
        resulting in a merge conflict. One workaround is to use
        <code class="literal">git checkout</code> followed by
        <code class="literal">git commit -C</code> on the initial
        commit, then rebase the rest.</p>

        <p>There are worse cases unfortunately. If several branches
        with different initial commits are merged together, then
        rebasing the result requires substantial manual
        intervention.</p>
      </div>
    </div>
  </div>
</body>
</html>
